options {  
	MULTI=true;
    LOOKAHEAD=1;
    }

PARSER_BEGIN(Jmm)

import java.io.InputStream;
import java.io.FileInputStream;
import java.io.File;



public class Jmm {

    public static int max_errors = 10;
    public static boolean failed = false;

    public static void main(String args[]) throws ParseException {   

        	System.out.println("TESTE:");
	        InputStream initialStream = null;
	        try {
	            initialStream = new FileInputStream(new File(args[0]));
	        } catch(Exception e){
	            System.out.println("Could not found file");
	            System.exit(0);
	        }
	        
	        Jmm myJmm = new Jmm(initialStream);     
	        SimpleNode root = myJmm.Program();
	        root.dump("");
	       	System.out.println("LSD");
	       	if(2 == 5){
	       		throw new ParseException();
	       	}
	        
	       

    }
}
//TODO


PARSER_END(Jmm)

SKIP : {  " " | "\r" | "\t" | "\n" | <"//"(~[ "\n", "\r" ]) * ("\n" | "\r" | "\r\n")> |
      <"/*"(~["*"]) * "*"("*" | ~[ "*", "/" ](~["*"]) * "*") * "/"> } 

TOKEN:{
    <CLASS: "class">
    | <MAIN : "main">
    | <IF : "if">
    | <INT : "int">
    | <NEW : "new">
    | <ELSE : "else">
    | <TRUE : "true">
    | <FALSE : "false">
    | <THIS : "this">
    | <WHILE : "while">
    | <STATIC : "static">
    | <PUBLIC : "public">
    | <LENGTH : "length">
    | <RETURN : "return">
    | <IMPORT : "import">
    | <BOOL : "boolean">
    | <EXTENDS : "extends">
    | <VOID : "void">
    | <STRING : "String">

    | <CURLY_BRACE_OPEN : "{">
    | <CURLY_BRACE_CLOSE : "}">
    | <ROUND_BRACE_OPEN : "(">
    | <ROUND_BRACE_CLOSE : ")">
    | <SQUARE_BRACE_OPEN : "[">
    | <SQUARE_BRACE_CLOSE : "]">

    | <NOT : "!">

    | <SEMICOLON : ";">
    | <DOT : ".">
    | <COMMA : ",">

    | <EQUALS : "=">
    | <ADD : "+">
    | <SUB : "-">
    | <MUL : "*">
    | <DIV : "/">
    | <AND : "&&">
    | <LESS_THAN : "<">



    | <IDENTIFIER: ["A"-"Z" , "a"-"z", "_", "$"] (["0"-"9" ,"A"-"Z" , "a"-"z" , "_", "$"])*>
    | <INTEGERLITERAL: (["0"-"9"])+ >
}



ASTProgram Program(): {} {
    (ImportDeclaration() #IMPORT )* ClassDeclaration() <EOF>  {return jjtThis;}
}

void ImportDeclaration() #void: { Token t1;String s1,s2;} {
    <IMPORT> 
    ( <STATIC> 
        t1 = <IDENTIFIER> {  jjtThis.name = t1.image; jjtThis.is_static = true; jjtThis.lineNo = t1.beginLine; } #CLASS MethodImport()
        | t1 = <IDENTIFIER> {  jjtThis.name = t1.image; jjtThis.lineNo = t1.beginLine; } #CLASS [   <ROUND_BRACE_OPEN> [(s1 = Type() {  jjtThis.type =s1; jjtThis.lineNo = t1.beginLine; } #PARAM) ("," (s2 = Type(){  jjtThis.type =s2; jjtThis.lineNo = t1.beginLine; } #PARAM))*] #PARAMS <ROUND_BRACE_CLOSE>    |  MethodImport() ])
     <SEMICOLON> 
}

void MethodImport() #void: {Token t1,t2;String s1,s2,s3;} {
    <DOT> ( ( t1 = <IDENTIFIER> | t1 = <LENGTH> ) {  jjtThis.name = t1.image; jjtThis.type = "void"; jjtThis.lineNo = t1.beginLine; } 
     <ROUND_BRACE_OPEN> [ (s1 = Type() {  jjtThis.type =s1; jjtThis.lineNo = t1.beginLine; } #PARAM) ("," (s2 = Type(){  jjtThis.type =s2; jjtThis.lineNo = t1.beginLine; } #PARAM))*] #PARAMS <ROUND_BRACE_CLOSE> 
    [ s3=Type() {  jjtThis.type =s3; jjtThis.lineNo = t1.beginLine; } ] ) #METHOD_PROT
}

void ClassDeclaration() #CLASS_DECL: {Token t1;} {
    <CLASS> t1 = <IDENTIFIER> {  jjtThis.name = t1.image; jjtThis.lineNo = t1.beginLine; } [ <EXTENDS> t1 = <IDENTIFIER> {  jjtThis.name = t1.image; jjtThis.lineNo = t1.beginLine; } #EXTENDS ] <CURLY_BRACE_OPEN>
    ( VarDeclaration()  )* 
    ( MethodDeclaration()  )* 
    <CURLY_BRACE_CLOSE>
}


void MethodDeclaration() #METHOD: {Token t1,t2,t3;String s1;} {
    <PUBLIC>
    (    s1 = Type() { jjtThis.type = s1;} t1 = <IDENTIFIER> {  jjtThis.name = t1.image; jjtThis.lineNo = t1.beginLine; } 
            <ROUND_BRACE_OPEN> ( [ Argument() ( <COMMA> Argument() )* ] )  <ROUND_BRACE_CLOSE> 
            ( <CURLY_BRACE_OPEN> 
	            MethodBody()
	            <RETURN> (Expression() #EXPRESSION) #RETURN_EXPRESSION <SEMICOLON>
        	<CURLY_BRACE_CLOSE> ) #METHOD_BODY
    | 
        <STATIC> <VOID> t1 = <MAIN> {  jjtThis.name = t1.image; jjtThis.type = "void"; }
        	<ROUND_BRACE_OPEN> ( <STRING> <SQUARE_BRACE_OPEN> <SQUARE_BRACE_CLOSE> t1 = <IDENTIFIER> {  jjtThis.type = "String[]" ; jjtThis.name = t1.image; jjtThis.lineNo = t1.beginLine; } ) #ARGUMENT <ROUND_BRACE_CLOSE> 
			( <CURLY_BRACE_OPEN> 
            	MethodBody()
        	<CURLY_BRACE_CLOSE> ) #METHOD_BODY
    )
    
}

void Argument() #ARGUMENT: {Token t1; String s1;} {
	s1 = Type() t1 = <IDENTIFIER> { jjtThis.type = s1; jjtThis.name = t1.image; ; jjtThis.lineNo = t1.beginLine; }
}

void MethodBody() #void: {} {
    (LOOKAHEAD(2)( VarDeclaration()  ))*
    ( Statement() )* 
}

void VarDeclaration() #VAR_DEC: {Token t1;String s1;} {
    s1 = Type()  t1 = <IDENTIFIER>  { jjtThis.type = s1; jjtThis.name = t1.image; jjtThis.lineNo = t1.beginLine; } <SEMICOLON> 
}

String Type() #void: {Token t1; String s1 = "";} {
     ( t1 = <INT> [ <SQUARE_BRACE_OPEN> <SQUARE_BRACE_CLOSE> {s1 = "[]";} ] {  return t1.image + s1 ; } )
    | t1 = <BOOL> {  return t1.image; }
    | t1 = <IDENTIFIER> {  return t1.image; }
    | t1 = <VOID> {  return t1.image; } 
}

void Statement() #void: {Token t1;} {
   
    ( <CURLY_BRACE_OPEN> ( Statement()  )* <CURLY_BRACE_CLOSE> ) #CODE_BLOCK

    | If()
    
    | While()
    
    |  LOOKAHEAD(2)( t1 = <IDENTIFIER>  { jjtThis.name = t1.image; ; jjtThis.lineNo = t1.beginLine; } #IDENTIFIER 
        [ <SQUARE_BRACE_OPEN> ( Expression() #EXPRESSION ) <SQUARE_BRACE_CLOSE> ] 
      ) #VAR
        <EQUALS> ( Expression() #EXPRESSION )  #ASSIGN_VAR(2) <SEMICOLON>
    |  Expression() #EXPRESSION <SEMICOLON>
}

void If() #IF_STATEMENT: {} {
	<IF> <ROUND_BRACE_OPEN> Condition() <ROUND_BRACE_CLOSE> 
	    Statement() #IF_BODY 
	 <ELSE>
	 	Statement() #ELSE_BODY
}

void Condition() #CONDITION: {} {
	Expression() #EXPRESSION
}

void While() #void: {} {
    (<WHILE>
        try {
        <ROUND_BRACE_OPEN> Condition() <ROUND_BRACE_CLOSE>
        }
        catch (ParseException e) {
            Jmm.max_errors--;
            Jmm.failed = true;
            System.out.println("Exception on WHILE CONDITION caught.");
            System.out.println(e.toString());  // print the error message
            error_skipto(e, ROUND_BRACE_CLOSE);
            if(Jmm.max_errors == 0)
                throw e;
        }
        Statement() #BODY) #WHILE
    
}


void Expression() #void: {} {
	AndAritm()
}

void AndAritm() #void : {Token t1;} {
    LessAritm()
   		(LOOKAHEAD(2) t1 = <AND> LessAritm() {  jjtThis.name = t1.image; ; jjtThis.lineNo = t1.beginLine; } #OPERATOR(2) ) *
 }

void LessAritm() #void : {Token t1;} {
	AddSubAritm() 
   		[LOOKAHEAD(2) t1 = <LESS_THAN> AddSubAritm() {  jjtThis.name = t1.image; ; jjtThis.lineNo = t1.beginLine; } #OPERATOR(2) ]
    	
}

void AddSubAritm() #void : {Token t1;} {
    MulDivAritm() 
    	(LOOKAHEAD(2)( t1 = <ADD> | t1 = <SUB> ) AddSubAritm() {  jjtThis.name = t1.image; ; jjtThis.lineNo = t1.beginLine; } #OPERATOR(2))*
    
}

void MulDivAritm() #void : {Token t1;} {
	ExpTerminal() 
    	(LOOKAHEAD(2)( t1 = <MUL> | t1 = <DIV> ) MulDivAritm() { jjtThis.name = t1.image; ; jjtThis.lineNo = t1.beginLine; } #OPERATOR(2) )*
}

void ExpTerminal() #void : {Token t1;} {
	( t1 = <IDENTIFIER> {  jjtThis.name = t1.image; jjtThis.lineNo = t1.beginLine; }  #IDENTIFIER
    | t1 = <INTEGERLITERAL> {  jjtThis.val = Integer.parseInt(t1.image); jjtThis.type = "int"; jjtThis.lineNo = t1.beginLine; }  #INTEGERLITERAL 
    | t1 = <TRUE> {  jjtThis.val = 1; jjtThis.type = "boolean"; jjtThis.lineNo = t1.beginLine; } #BOOL
    | t1 = <FALSE> {  jjtThis.val = 0; jjtThis.type = "boolean"; jjtThis.lineNo = t1.beginLine; } #BOOL
    | t1 =  <THIS> {  jjtThis.name = t1.image; ; jjtThis.lineNo = t1.beginLine; } #THIS
    | <NEW>( ( <INT> <SQUARE_BRACE_OPEN> Expression() #EXPRESSION <SQUARE_BRACE_CLOSE> ) #NEW_INT_ARR
    |  (t1 = <IDENTIFIER> {  jjtThis.name = t1.image; ; jjtThis.lineNo = t1.beginLine; } #TYPE <ROUND_BRACE_OPEN> ( [ LOOKAHEAD(2) ( (Expression() #EXPRESSION) #PARAM)  (<COMMA> (Expression()#EXPRESSION) #PARAM )* ] ) #PARAMS <ROUND_BRACE_CLOSE>) #NEW_IDENTIFIER )
    )
    [ extendTerminal() ]
    | ( <NOT> Expression() )  #NOT_EXPRESSION(1)
    |ParExpression()
}

void extendTerminal() #void: {Token t1;} {
	(<SQUARE_BRACE_OPEN> Expression() #EXPRESSION <SQUARE_BRACE_CLOSE>) #ARRAY_ACESS(2) [ extendTerminal() ] 
    | <DOT> ( ( <LENGTH> #LENGTH(1)  [ extendTerminal() ] ) 
          	  | (  ( t1 = <IDENTIFIER> {  jjtThis.name = t1.image; ; jjtThis.lineNo = t1.beginLine; }
               <ROUND_BRACE_OPEN> ( [ LOOKAHEAD(2) ( (Expression() #EXPRESSION) #PARAM)  (<COMMA> (Expression()#EXPRESSION) #PARAM )* ] ) #PARAMS <ROUND_BRACE_CLOSE> ) #FUNCTION (2)  [ extendTerminal()  ] ) )
}

void ParExpression() #void : {} {	
	<ROUND_BRACE_OPEN>
        try {
             Expression() #PAR_EXPRESSION <ROUND_BRACE_CLOSE> 
        }
        catch (ParseException e) {
            //System.out.println("Exception on ROUND_BRACES caught.");
            error_skipto(e, ROUND_BRACE_CLOSE);
            throw e;
        }
}



JAVACODE
void error_skipto(ParseException e, int kind) {
  //System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
    if(t.kind == ROUND_BRACE_OPEN){
        error_skipto(e,ROUND_BRACE_CLOSE);
    }
  } while (t.kind != kind  && t.kind != EOF);
}