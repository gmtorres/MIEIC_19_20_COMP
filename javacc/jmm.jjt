options { LOOKAHEAD = 2; }

PARSER_BEGIN(Jmm)

import java.io.InputStream;
import java.io.FileInputStream;
import java.io.File;



public class Jmm {

    public static int max_errors = 10;

    public static void main(String args[]) throws ParseException {   

        	System.out.println("TESTE:");
	        InputStream initialStream = null;
	        try {
	            initialStream = new FileInputStream(new File(args[0]));
	        } catch(Exception e){
	            System.out.println("Could not found file");
	            System.exit(0);
	        }
	        
	        Jmm myJmm = new Jmm(initialStream);     
	        SimpleNode root = myJmm.Program();
	        root.dump("");
	        
	        
	        throw new ParseException();


    }
}
//TODO


PARSER_END(Jmm)

SKIP : {  " " | "\r" | "\t" | "\n" | <"//"(~[ "\n", "\r" ]) * ("\n" | "\r" | "\r\n")> |
      <"/*"(~["*"]) * "*"("*" | ~[ "*", "/" ](~["*"]) * "*") * "/"> } 

TOKEN:{
    <CLASS: "class">
    | <MAIN : "main">
    | <IF : "if">
    | <INT : "int">
    | <NEW : "new">
    | <ELSE : "else">
    | <TRUE : "true">
    | <FALSE : "false">
    | <THIS : "this">
    | <WHILE : "while">
    | <STATIC : "static">
    | <PUBLIC : "public">
    | <LENGTH : "length">
    | <RETURN : "return">
    | <IMPORT : "import">
    | <BOOL : "boolean">
    | <EXTENDS : "extends">
    | <VOID : "void">
    | <STRING : "String">

    | <CURLY_BRACE_OPEN : "{">
    | <CURLY_BRACE_CLOSE : "}">
    | <ROUND_BRACE_OPEN : "(">
    | <ROUND_BRACE_CLOSE : ")">
    | <SQUARE_BRACE_OPEN : "[">
    | <SQUARE_BRACE_CLOSE : "]">

    | <NOT : "!">

    | <SEMICOLON : ";">
    | <EQUALS : "=">



    | <IDENTIFIER: ["A"-"Z" , "a"-"z", "_", "$"] (["0"-"9" ,"A"-"Z" , "a"-"z" , "_", "$"])*>
    | <INTEGERLITERAL: (["0"-"9"])+ >
}



SimpleNode Program(): {} {
    (ImportDeclaration() #IMPORT_DECLARATION )* ClassDeclaration() #CLASS_DECLARATION <EOF>  {return jjtThis;}
}

void ImportDeclaration() #void: {} {
    <IMPORT> ( <STATIC> <IDENTIFIER> MethodImport() #METHOD_IMPORT
             | <IDENTIFIER> [MethodImport() #METHOD_IMPORT])
     <SEMICOLON> 
}

void MethodImport() #void: {} {
    "." <IDENTIFIER> <ROUND_BRACE_OPEN> [Type() ("," Type())*] <ROUND_BRACE_CLOSE> [Type()]
}

void ClassDeclaration() #void: {} {
    <CLASS> <IDENTIFIER> [ <EXTENDS> <IDENTIFIER> ] "{" 
    ( VarDeclaration() #VAR_DECLARATION_CLASS )* 
    ( MethodDeclaration() #METHOD_DECLARATION )* 
    "}" 
}


void MethodDeclaration() #void: {} {
    <PUBLIC> Type() <IDENTIFIER> "(" [ Type() <IDENTIFIER> ("," Type() <IDENTIFIER> )* ] ")" "{" 
        ( VarDeclaration() #VAR_DECLARATION_METHOD )* 
        ( Statement() #METHOD_STATEMENT )* 
        <RETURN> Expression() #RETURN_EXPRESSION ";" "}"
        | <PUBLIC> <STATIC> <VOID> <MAIN> "(" <STRING> "[" "]" <IDENTIFIER> ")" "{" ( VarDeclaration() )* ( Statement() )* "}"
    
}

void VarDeclaration() #void: {} {
    Type() <IDENTIFIER> ";"     
}

void Type() #void: {} {
    <INT> "[" "]"
    | <BOOL>
    | <INT>
    | <IDENTIFIER>
    | <VOID>
}

void Statement() #void: {} {
    
    <CURLY_BRACE_OPEN> 
        
            ( Statement() #INLINE_STATEMENT )* <CURLY_BRACE_CLOSE>

    | <IF> 
        
            <ROUND_BRACE_OPEN> Expression() #IF_CONDITION <ROUND_BRACE_CLOSE> 
            Statement() #IF_STATAMENT_BODY 
            <ELSE> Statement() #ELSE_STATEMENT_BODY
    | While()

    |  <IDENTIFIER> <EQUALS> Expression() #ASSIGN1 <SEMICOLON>

    | <IDENTIFIER> <SQUARE_BRACE_OPEN> Expression() <SQUARE_BRACE_CLOSE> 
    <EQUALS> Expression() #ASSIGN2 <SEMICOLON>

    |  Expression() #EXPRESSION1 <SEMICOLON>


}

void While() #void: {} {
    <WHILE>
        try {
        <ROUND_BRACE_OPEN> Expression()  #WHILE_CONDITION <ROUND_BRACE_CLOSE>
        }
        catch (ParseException e) {
            Jmm.max_errors--;
            System.out.println("Exception on WHILE CONDITION caught.");
            System.out.println(e.toString());  // print the error message
            error_skipto(e, ROUND_BRACE_CLOSE);
            if(Jmm.max_errors == 0)
                throw e;
        }
        Statement() #WHILE_STATEMENT
    
}

void Expression() #void: {} {
    ( <IDENTIFIER> #IDENTIFIER
    | <INTEGERLITERAL> #INTEGERLITERAL
    | <TRUE> #BOOL_TRUE
    | <FALSE> #BOOL_FALSE
    | <THIS> #THIS
    | <NEW> <INT> <SQUARE_BRACE_OPEN> Expression() <SQUARE_BRACE_CLOSE> #NEW_INT_EXPRESSION
    | <NEW> <IDENTIFIER> <ROUND_BRACE_OPEN> <ROUND_BRACE_CLOSE> #NEW_ID
    | <NOT> Expression() #NOT_EXPRESSION
    | <ROUND_BRACE_OPEN>
        try {
             Expression() <ROUND_BRACE_CLOSE> #PAR_EXPRESSION
        }
        catch (ParseException e) {
            //System.out.println("Exception on ROUND_BRACES caught.");
            error_skipto(e, ROUND_BRACE_CLOSE);
            throw e;
        }
     )
    [ Expression2() ]
}

void Expression2() #void: {} {
    "[" Expression() #BRACKETS_EXPRESSION "]" [ Expression2() ] 
    | "." "length" #LENGTH [ Expression2() ] 
    |  "&&" Expression() #AND(2)
    |  "+" Expression() #ADD(2) | "-" Expression() #SUB(2) | "/" Expression() #DIV(2) | "*" Expression() #MULT(2) | "<" Expression() #LESS_THAN(2) 
    | "." <IDENTIFIER> "(" [ Expression()  ("," Expression() )* ] ")" [ Expression2() ]

}


JAVACODE
void error_skipto(ParseException e, int kind) {
  //System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
    if(t.kind == ROUND_BRACE_OPEN){
        error_skipto(e,ROUND_BRACE_CLOSE);
    }
  } while (t.kind != kind);
}