options {  
	MULTI=true;
    LOOKAHEAD=1;
    }

PARSER_BEGIN(Jmm)

import java.io.InputStream;
import java.io.FileInputStream;
import java.io.File;



public class Jmm {

    public static int max_errors = 10;
    public static boolean failed = false;

    public static void main(String args[]) throws ParseException {   

        	System.out.println("TESTE:");
	        InputStream initialStream = null;
	        try {
	            initialStream = new FileInputStream(new File(args[0]));
	        } catch(Exception e){
	            System.out.println("Could not found file");
	            System.exit(0);
	        }
	        
	        Jmm myJmm = new Jmm(initialStream);     
	        SimpleNode root = myJmm.Program();
	        root.dump("");
	       	System.out.println("LSD");
	       	if(2 == 5){
	       		throw new ParseException();
	       	}
	        
	       

    }
}
//TODO


PARSER_END(Jmm)

SKIP : {  " " | "\r" | "\t" | "\n" | <"//"(~[ "\n", "\r" ]) * ("\n" | "\r" | "\r\n")> |
      <"/*"(~["*"]) * "*"("*" | ~[ "*", "/" ](~["*"]) * "*") * "/"> } 

TOKEN:{
    <CLASS: "class">
    | <MAIN : "main">
    | <IF : "if">
    | <INT : "int">
    | <NEW : "new">
    | <ELSE : "else">
    | <TRUE : "true">
    | <FALSE : "false">
    | <THIS : "this">
    | <WHILE : "while">
    | <STATIC : "static">
    | <PUBLIC : "public">
    | <LENGTH : "length">
    | <RETURN : "return">
    | <IMPORT : "import">
    | <BOOL : "boolean">
    | <EXTENDS : "extends">
    | <VOID : "void">
    | <STRING : "String">

    | <CURLY_BRACE_OPEN : "{">
    | <CURLY_BRACE_CLOSE : "}">
    | <ROUND_BRACE_OPEN : "(">
    | <ROUND_BRACE_CLOSE : ")">
    | <SQUARE_BRACE_OPEN : "[">
    | <SQUARE_BRACE_CLOSE : "]">

    | <NOT : "!">

    | <SEMICOLON : ";">
    | <DOT : ".">
    | <COMMA : ",">

    | <EQUALS : "=">
    | <ADD : "+">
    | <SUB : "-">
    | <MUL : "*">
    | <DIV : "/">
    | <AND : "&&">
    | <LESS_THAN : "<">



    | <IDENTIFIER: ["A"-"Z" , "a"-"z", "_", "$"] (["0"-"9" ,"A"-"Z" , "a"-"z" , "_", "$"])*>
    | <INTEGERLITERAL: (["0"-"9"])+ >
}



ASTProgram Program(): {} {
    (ImportDeclaration() #IMPORT )* ClassDeclaration() <EOF>  {return jjtThis;}
}

void ImportDeclaration() #void: { Token t1;} {
    <IMPORT> 
    ( <STATIC> 
        t1 = <IDENTIFIER> {  jjtThis.name = "static " + t1.image; } #CLASS MethodImport()
        | t1 = <IDENTIFIER> {  jjtThis.name = t1.image; } #CLASS [MethodImport() ])
     <SEMICOLON> 
}

void MethodImport() #void: {Token t1,t2;String s1,s2,s3;} {
    <DOT> ( t1 = <IDENTIFIER> {  jjtThis.name = t1.image; jjtThis.type = "void"; } 
     <ROUND_BRACE_OPEN> [(s1 = Type() {  jjtThis.type =s1; } #PARAM) ("," (s2 = Type(){  jjtThis.type =s2; } #PARAM))*] #PARAMS <ROUND_BRACE_CLOSE> 
    [ s3=Type() {  jjtThis.type =s3; } ] ) #METHOD_PROT
}

void ClassDeclaration() #CLASS: {Token t1;} {
    <CLASS> t1 = <IDENTIFIER> {  jjtThis.name = t1.image; } [ <EXTENDS> t1 = <IDENTIFIER> {  jjtThis.name = t1.image; } #EXTENDS ] <CURLY_BRACE_OPEN>
    ( VarDeclaration()  )* 
    ( MethodDeclaration()  )* 
    <CURLY_BRACE_CLOSE>
}


void MethodDeclaration() #METHOD: {Token t1,t2,t3;String s1;} {
    <PUBLIC>
    (    s1 = Type() { jjtThis.type = s1;} t1 = <IDENTIFIER> {  jjtThis.name = t1.image; } 
            <ROUND_BRACE_OPEN> ( [ Argument() ( <COMMA> Argument() )* ] )  <ROUND_BRACE_CLOSE> 
            ( <CURLY_BRACE_OPEN> 
	            MethodBody()
	            <RETURN> (Expression() #EXPRESSION) #RETURN_EXPRESSION <SEMICOLON>
        	<CURLY_BRACE_CLOSE> ) #METHOD_BODY
    | 
        <STATIC> <VOID> t1 = <MAIN> {  jjtThis.name = t1.image; }
        	<ROUND_BRACE_OPEN> ( <STRING> <SQUARE_BRACE_OPEN> <SQUARE_BRACE_CLOSE> t1 = <IDENTIFIER> {  jjtThis.type = "String []" ; jjtThis.name = t1.image; } ) #ARGUMENT <ROUND_BRACE_CLOSE> 
			( <CURLY_BRACE_OPEN> 
            	MethodBody()
        	<CURLY_BRACE_CLOSE> ) #METHOD_BODY
    )
    
}

void Argument() #ARGUMENT: {Token t1; String s1;} {
	s1 = Type() t1 = <IDENTIFIER> { jjtThis.type = s1; jjtThis.name = t1.image; }
}

void MethodBody() #void: {} {
    (LOOKAHEAD(2)( VarDeclaration()  ))*
    ( Statement() )* 
}

void VarDeclaration() #VAR_DEC: {Token t1;String s1;} {
    s1 = Type()  t1 = <IDENTIFIER>  { jjtThis.type = s1; jjtThis.name = t1.image; } <SEMICOLON>     
}

String Type() #void: {Token t1; String s1 = "";} {
     ( t1 = <INT> [ <SQUARE_BRACE_OPEN> <SQUARE_BRACE_CLOSE> {s1 = "[]";} ] {  return t1.image + s1 ; } )
    | t1 = <BOOL> {  return t1.image; }
    | t1 = <IDENTIFIER> {  return t1.image; }
    | t1 = <VOID> {  return t1.image; } 
}

void Statement() #void: {Token t1;} {
   
    ( <CURLY_BRACE_OPEN> ( Statement()  )* <CURLY_BRACE_CLOSE> ) #CODE_BLOCK

    | If()
    
    | While()
    
    |  LOOKAHEAD(2)( t1 = <IDENTIFIER>  { jjtThis.name = t1.image; } #IDENTIFIER 
        [ <SQUARE_BRACE_OPEN> ( Expression() #EXPRESSION ) <SQUARE_BRACE_CLOSE> ] 
      ) #VAR
        <EQUALS> ( Expression() #EXPRESSION )  #ASSIGN_VAR(2) <SEMICOLON>
    |  Expression() #EXPRESSION <SEMICOLON>
}

void If() #IF_STATEMENT: {} {
	<IF> <ROUND_BRACE_OPEN> Condition() <ROUND_BRACE_CLOSE> 
	    Statement() #BODY 
	 <ELSE>
	 	Statement() #BODY
}

void Condition() #CONDITION: {} {
	Expression() #EXPRESSION
}

void While() #void: {} {
    (<WHILE>
        try {
        <ROUND_BRACE_OPEN> Condition() <ROUND_BRACE_CLOSE>
        }
        catch (ParseException e) {
            Jmm.max_errors--;
            Jmm.failed = true;
            System.out.println("Exception on WHILE CONDITION caught.");
            System.out.println(e.toString());  // print the error message
            error_skipto(e, ROUND_BRACE_CLOSE);
            if(Jmm.max_errors == 0)
                throw e;
        }
        Statement() #BODY) #WHILE
    
}

void Expression() #void: {Token t1;} {
    ( t1 = <IDENTIFIER> {  jjtThis.name = t1.image; }  #IDENTIFIER
    | t1 = <INTEGERLITERAL> {  jjtThis.val = Integer.parseInt(t1.image); jjtThis.type = "int"; }  #INTEGERLITERAL
    | t1 = <TRUE> {  jjtThis.val = 1; jjtThis.type = "bool"; } #BOOL
    | t1 = <FALSE> {  jjtThis.val = 0; jjtThis.type = "bool"; } #BOOL
    | t1 =  <THIS> {  jjtThis.name = t1.image; } #THIS
    | <NEW>( ( <INT> <SQUARE_BRACE_OPEN> Expression() #EXPRESSION <SQUARE_BRACE_CLOSE> ) #NEW_INT_ARR
    |  (t1 = <IDENTIFIER> {  jjtThis.name = t1.image; } #TYPE <ROUND_BRACE_OPEN> <ROUND_BRACE_CLOSE>) #NEW_IDENTIFIER )

    | <ROUND_BRACE_OPEN>
        try {
             Expression() #PAR_EXPRESSION <ROUND_BRACE_CLOSE> 
        }
        catch (ParseException e) {
            //System.out.println("Exception on ROUND_BRACES caught.");
            error_skipto(e, ROUND_BRACE_CLOSE);
            throw e;
        }
     )
    [ Expression2() ]
    | ( <NOT> Expression() ) {  jjtThis.type = "bool"; }  #NOT_EXPRESSION
}

void Expression2() #void: {Token t1;} {
    (<SQUARE_BRACE_OPEN> Expression() #INDEX <SQUARE_BRACE_CLOSE>) #ARRAY_ACESS(2) [ Expression2() ] 
    | <DOT> ( ( <LENGTH> {  jjtThis.type = "int"; } #LENGTH(1)  [ Expression2() ] ) 
          	  | (  ( t1 = <IDENTIFIER> {  jjtThis.name = t1.image; jjtThis.type = "int"; }
               <ROUND_BRACE_OPEN> ( [ LOOKAHEAD(2) (Expression() #PARAM)  (<COMMA> Expression() #PARAM )* ] ) #PARAMS <ROUND_BRACE_CLOSE> ) #FUNCTION (2)  [ Expression2()  ] ) )
    | Aritm() 
    
}

void Aritm() #OPERATOR(2) : {Token t1;} {
    t1 = <AND> Expression() {  jjtThis.name = t1.image; }
    | t1 = <ADD> Expression() {  jjtThis.name = t1.image; } 
    | t1 = <SUB> Expression() {  jjtThis.name = t1.image; }
    | t1 = <DIV> Expression() {  jjtThis.name = t1.image; } 
    | t1 = <MUL> Expression() {  jjtThis.name = t1.image; }
    | t1 = <LESS_THAN> Expression() {  jjtThis.name = t1.image; }
}

JAVACODE
void error_skipto(ParseException e, int kind) {
  //System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
    if(t.kind == ROUND_BRACE_OPEN){
        error_skipto(e,ROUND_BRACE_CLOSE);
    }
  } while (t.kind != kind  && t.kind != EOF);
}