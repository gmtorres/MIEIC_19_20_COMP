options { LOOKAHEAD = 1; }

PARSER_BEGIN(Jmm)

import java.io.InputStream;
import java.io.FileInputStream;
import java.io.File;



public class Jmm {

    public static int max_errors = 10;
    public static boolean failed = false;

    public static void main(String args[]) throws ParseException {   

        	System.out.println("TESTE:");
	        InputStream initialStream = null;
	        try {
	            initialStream = new FileInputStream(new File(args[0]));
	        } catch(Exception e){
	            System.out.println("Could not found file");
	            System.exit(0);
	        }
	        
	        Jmm myJmm = new Jmm(initialStream);     
	        SimpleNode root = myJmm.Program();
	        root.dump("");
	       	System.out.println("LSD");
	       	if(2 == 5){
	       		throw new ParseException();
	       	}
	        
	       

    }
}
//TODO


PARSER_END(Jmm)

SKIP : {  " " | "\r" | "\t" | "\n" | <"//"(~[ "\n", "\r" ]) * ("\n" | "\r" | "\r\n")> |
      <"/*"(~["*"]) * "*"("*" | ~[ "*", "/" ](~["*"]) * "*") * "/"> } 

TOKEN:{
    <CLASS: "class">
    | <MAIN : "main">
    | <IF : "if">
    | <INT : "int">
    | <NEW : "new">
    | <ELSE : "else">
    | <TRUE : "true">
    | <FALSE : "false">
    | <THIS : "this">
    | <WHILE : "while">
    | <STATIC : "static">
    | <PUBLIC : "public">
    | <LENGTH : "length">
    | <RETURN : "return">
    | <IMPORT : "import">
    | <BOOL : "boolean">
    | <EXTENDS : "extends">
    | <VOID : "void">
    | <STRING : "String">

    | <CURLY_BRACE_OPEN : "{">
    | <CURLY_BRACE_CLOSE : "}">
    | <ROUND_BRACE_OPEN : "(">
    | <ROUND_BRACE_CLOSE : ")">
    | <SQUARE_BRACE_OPEN : "[">
    | <SQUARE_BRACE_CLOSE : "]">

    | <NOT : "!">

    | <SEMICOLON : ";">
    | <DOT : ".">
    | <COMMA : ",">

    | <EQUALS : "=">
    | <ADD : "+">
    | <SUB : "-">
    | <MUL : "*">
    | <DIV : "/">
    | <AND : "&&">
    | <LESS_THAN : "<">



    | <IDENTIFIER: ["A"-"Z" , "a"-"z", "_", "$"] (["0"-"9" ,"A"-"Z" , "a"-"z" , "_", "$"])*>
    | <INTEGERLITERAL: (["0"-"9"])+ >
}



SimpleNode Program(): {} {
    (ImportDeclaration() #IMPORT_DEC )* ClassDeclaration() #CLASS_DEC <EOF>  {return jjtThis;}
}

void ImportDeclaration() #void: { Token t1;} {
    <IMPORT> 
    ( <STATIC> 
        t1 = <IDENTIFIER> {  jjtThis.name = t1.image; } #LIB MethodImport()
        | t1 = <IDENTIFIER> {  jjtThis.name = t1.image; } #LIB [MethodImport() ])
     <SEMICOLON> 
}

void MethodImport() #void: {Token t1,t2;} {
    "." t1 = <IDENTIFIER> {  jjtThis.name = t1.image; } #METHOD <ROUND_BRACE_OPEN> [Type() ("," Type())*] #PARAMS <ROUND_BRACE_CLOSE> [Type() #FCNT_RETURN]
}

void ClassDeclaration() #void: {Token t1;} {
    <CLASS> t1 = <IDENTIFIER> {  jjtThis.name = t1.image; } #CLASS_NAME [ <EXTENDS> <IDENTIFIER> ] "{" 
    ( VarDeclaration() #VAR_DEC )* 
    ( MethodDeclaration() #METHOD_DEC )* 
    "}" 
}


void MethodDeclaration() #void: {Token t1,t2,t3;} {
    <PUBLIC>
    (    Type() #RETURN_TYPE t1 = <IDENTIFIER> {  jjtThis.name = t1.image; } #METHOD_NAME 
            <ROUND_BRACE_OPEN> [ Argument() ( <COMMA> Argument() )* ]  <ROUND_BRACE_CLOSE> 
            <CURLY_BRACE_OPEN> 
	            MethodBody()
	            <RETURN> (Expression() #EXPRESSION) #RETURN_EXPRESSION <SEMICOLON>
        	<CURLY_BRACE_CLOSE>
    | 
        <STATIC> <VOID> t1 = <MAIN> {  jjtThis.name = t1.image; } #METHOD_NAME 
        	<ROUND_BRACE_OPEN> <STRING> <SQUARE_BRACE_OPEN> <SQUARE_BRACE_CLOSE> <IDENTIFIER>  <ROUND_BRACE_CLOSE> 
			<CURLY_BRACE_OPEN> 
            	MethodBody()
        	<CURLY_BRACE_CLOSE>
    )
    
}

void Argument() #ARGUMENT: {Token t1; String s1;} {
	s1 = Type() t1 = <IDENTIFIER> { jjtThis.type = s1; jjtThis.name = t1.image; }
}

void MethodBody() #void: {} {
    (LOOKAHEAD(2)( VarDeclaration()  ))*
    ( Statement() )* 
}

void VarDeclaration() #VAR_DEC: {Token t1;String s1;} {
    s1 = Type()  t1 = <IDENTIFIER>  { jjtThis.type = s1; jjtThis.name = t1.image; } <SEMICOLON>     
}

String Type() #void: {Token t1; String s1 = "";} {
     ( t1 = <INT> [ <SQUARE_BRACE_OPEN> <SQUARE_BRACE_CLOSE> {s1 = "[]";} ] {  return t1.image + s1 ; } )
    | t1 = <BOOL> {  return t1.image; }
    | t1 = <IDENTIFIER> {  return t1.image; }
    | t1 = <VOID> {  return t1.image; } 
}

void Statement() #void: {Token t1;} {
    LOOKAHEAD(2)
    <CURLY_BRACE_OPEN> ( Statement()  )* <CURLY_BRACE_CLOSE>

    | <IF> <ROUND_BRACE_OPEN> ( Expression() #EXPRESSION ) #IF_CONDITION <ROUND_BRACE_CLOSE> 
            Statement() #IF_STATAMENT_BODY 
            <ELSE> Statement() #ELSE_STATEMENT_BODY
    | While()
    
    |  LOOKAHEAD(2)( t1 = <IDENTIFIER>  { jjtThis.name = t1.image; } #IDENTIFIER 
        [ <SQUARE_BRACE_OPEN> ( Expression() #EXPRESSION ) #INDEX <SQUARE_BRACE_CLOSE> ] 
      ) #VAR
        <EQUALS> ( Expression() #EXPRESSION )  #ASSIGN_VAR(2) <SEMICOLON>
    |  Expression() #EXPRESSION <SEMICOLON>
}

void While() #void: {} {
    (<WHILE>
        try {
        <ROUND_BRACE_OPEN> ( Expression() #EXPRESSION )  #WHILE_CONDITION <ROUND_BRACE_CLOSE>
        }
        catch (ParseException e) {
            Jmm.max_errors--;
            Jmm.failed = true;
            System.out.println("Exception on WHILE CONDITION caught.");
            System.out.println(e.toString());  // print the error message
            error_skipto(e, ROUND_BRACE_CLOSE);
            if(Jmm.max_errors == 0)
                throw e;
        }
        Statement() #WHILE_STATEMENT) #WHILE
    
}

void Expression() #void: {Token t1;} {
    ( t1 = <IDENTIFIER> {  jjtThis.name = t1.image; }  #IDENTIFIER
    | t1 = <INTEGERLITERAL> {  jjtThis.val = Integer.parseInt(t1.image); }  #INTEGERLITERAL
    | t1 = <TRUE> {  jjtThis.val = 1; } #BOOL_TRUE
    | t1 = <FALSE> {  jjtThis.val = 0; } #BOOL_FALSE
    | t1 =  <THIS> {  jjtThis.name = t1.image; } #THIS
    | <NEW>( ( <INT> <SQUARE_BRACE_OPEN> Expression() #SIZE <SQUARE_BRACE_CLOSE> ) #NEW_INT_ARR
    |  (t1 = <IDENTIFIER> {  jjtThis.name = t1.image; } #IDENTIFIER <ROUND_BRACE_OPEN> <ROUND_BRACE_CLOSE>) #NEW_IDENTIFIER )

    | <ROUND_BRACE_OPEN>
        try {
             Expression() #PAR_EXPRESSION <ROUND_BRACE_CLOSE> 
        }
        catch (ParseException e) {
            //System.out.println("Exception on ROUND_BRACES caught.");
            error_skipto(e, ROUND_BRACE_CLOSE);
            throw e;
        }
     )
    [ Expression2() ]
    | ( <NOT> Expression() ) #NOT_EXPRESSION
}

void Expression2() #void: {Token t1;} {
    <SQUARE_BRACE_OPEN> Expression() #INDEX <SQUARE_BRACE_CLOSE> [ Expression2() ] 
    | <DOT> ( ( <LENGTH> #LENGTH(1) [ Expression2() ] ) |
          ( t1 = <IDENTIFIER> {  jjtThis.name = t1.image; } #FUCTION 
            <ROUND_BRACE_OPEN> [ LOOKAHEAD(2) Expression()  (<COMMA> Expression() )* ] #PARAM <ROUND_BRACE_CLOSE> [ Expression2()  ] ) )
    | Aritm() 
    
}

void Aritm() #void : {} {
    <AND> Expression() #AND(2)
    | <ADD> Expression() #ADD(2) 
    | <SUB> Expression() #SUB(2) 
    | <DIV> Expression() #DIV(2) 
    | <MUL> Expression() #MULT(2) 
    | <LESS_THAN> Expression() #LESS_THAN(2)
}

JAVACODE
void error_skipto(ParseException e, int kind) {
  //System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
    if(t.kind == ROUND_BRACE_OPEN){
        error_skipto(e,ROUND_BRACE_CLOSE);
    }
  } while (t.kind != kind  && t.kind != EOF);
}